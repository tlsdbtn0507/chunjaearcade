<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>please feedback!</title>

  <!-- Press Start 2P 폰트 -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="./css/comments.css" />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

  <div class="container">
    <h1>please feedback!</h1>

    <!-- 댓글 스크롤 영역 -->
    <div class="comments-scroll"></div>

    <!-- 고정된 댓글 입력창 -->
    <div class="input-area-comment">
      <input type="text" class="commentinput" placeholder="글을 입력해주세요.">
      <select class="input-select">
        <option value="">게임선택</option>
        <option value="ddongpihagi">DdongPiHaGi</option>
        <option value="reactionTest">ReactionTest</option>
        <option value="catchMe">CatchMe</option>
        <option value="steelKing">SteelKing</option>
      </select>
      <button onclick="sendCommentHandler()"><img src="./src/send.png" alt="보내기 버튼" /></button>
    </div>
  </div>

  <!-- 뒤로가기 버튼 -->
  <button class="back-btn" onclick="history.back()">
    <img src="./src/toHomeBtn.png" alt="뒤로가기" />
  </button>

  <button class="home-btn" onclick="goHome()">
    <img src="./src/home.png" alt="뒤로가기" />
  </button>

</body>
<script>
  const supabaseUrl = 'https://xgxajgqqqirzhohqwtyc.supabase.co';
  const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhneGFqZ3FxcWlyemhvaHF3dHljIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQyOTc4MjQsImV4cCI6MjA2OTg3MzgyNH0.atWmo_9wUpEZFOjuPX0zeXRwIh2UVtI5yoJOF9BKBOo';
  const client = supabase.createClient(supabaseUrl, supabaseKey);

  const sendCommentHandler = async() => {
    const input = document.querySelector('.commentinput');
    const select = document.querySelector('.input-select');
    const commentText = input.value.trim();
    const game = select.value;

    if (commentText === '') {
      alert('댓글을 입력해주세요.');
      return;
    }

    if (game === '') {
      alert('게임을 선택해주세요.');
      return;
    }

    const result = await postComment(commentText,game);

    if (result) {
      // 입력 필드 초기화
      input.value = '';
      select.value = '';
      window.location.reload();
      return;
    }
  }

  const sendRecommentHandler = async (commentId) => {
    const input = document.getElementById(`reinput-${commentId}`);
    
    const commentText = input.value.trim();

    if (commentText === '') {
      alert('대댓글을 입력해주세요.');
      return;
    }

    const { data, error } = await client
      .from('recomments')
      .insert([
        { content: commentText, commentId: commentId }
      ]);

    if (error) {
      console.error('Error posting recomment:', error);
      alert('대댓글 게시에 실패했습니다. 다시 시도해주세요.');
      return;
    } else {
      input.value = ''; // 입력 필드 초기화
      renderComments(); // 댓글 목록 갱신
    }
  }

  const postComment = async (commentText, game) => {
    const { data, error } = await client
      .from('comments')
      .insert([
        { content: commentText, game: game }
      ]);

    if (error) {
      console.error('Error posting comment:', error);
      alert('댓글 게시에 실패했습니다. 다시 시도해주세요.');
      return false;
    } else {
      // 댓글을 성공적으로 게시한 후 UI 업데이트 로직을 추가할 수 있습니다.
      return true;
    }
  }

  const fetchComments = async () => {
    const { data, error } = await client
      .from('comments')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching comments:', error);
      return [];
    }
    return data;
  }

  const renderComments = async () => {
    const comments = await fetchComments();

    if (!comments || comments.length === 0) {
      document.querySelector('.comments-scroll').innerHTML = 
      `<div class="no-comments">
        <p>아직 댓글이 없습니다.</p>
        <p>첫 댓글을 남겨주세요!</p>
      </div>
      `;
      return;
    }

    const commentsScroll = document.querySelector('.comments-scroll');
    commentsScroll.innerHTML = ''; // 기존 댓글 초기화

    for(const comment of comments){
      const commentBox = document.createElement('div');
      commentBox.className = `comment-box[data-id="${comment.id}"]`;
      const date = new Date(comment.created_at);
      const formattedDate = `${date.getHours()}:${date.getMinutes()}`;
      const relativeTime = formatRelativeTime(comment.created_at);
      const commentGame = (game) => game.charAt(0).toUpperCase() + game.slice(1).replace(/([A-Z])/g, ' $1').trim();

      const recomments = await fetchRecomments(comment.id);

      commentBox.innerHTML = `
        <div style="margin-top: 1%;" class="nickname-time">익명${comment.id} ${relativeTime}</div>
        <div class="comment-content"> 
          <p><b>Game:</b> ${commentGame(comment.game)}</p>
          ${comment.content}
        </div>
        <div class="reply-indent">
          ${recomments.length > 0 ?
            recomments.map(r => `
              <div class="nickname-time">익명${r.id} ${formatRelativeTime(r.created_at)}</div>
              <div style="margin-bottom:1%;" class="comment-content">${r.content}</div>
            `).join('') : ''
          }
          <div class="input-area-comment">
            <input id="reinput-${comment.id}"" type="text" placeholder="글을 입력해주세요.">
            <button onclick="sendRecommentHandler(${comment.id})">
              <img src="./src/send.png" alt="보내기 버튼" />
            </button>
          </div>
        </div>
      `;

      commentsScroll.appendChild(commentBox);
  }
  };

  const fetchRecomments = async (commentId) => {
    const { data, error } = await client
      .from('recomments')
      .select('*')
      .eq('commentId', commentId)
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Error fetching recomments:', error);
      return [];
    }
    return data;
  };

  const formatRelativeTime = (utcString) => {
    const now = new Date();
    const target = new Date(utcString); // UTC 문자열 → Date 객체 변환
    const diffMs = now - target;        // 차이(ms)
    const diffMinutes = Math.floor(diffMs / (1000 * 60));

    if (diffMinutes < 1) {
      return '방금 전';
    }
    if (diffMinutes < 60) {
      return `${diffMinutes}분 전`;
    }

    const diffHours = Math.floor(diffMinutes / 60);
    if (diffHours < 24) {
      return `${diffHours}시간 전`;
    }

    // 24시간 이상이면 yyyy-mm-dd 포맷
    const yyyy = target.getFullYear();
    const mm = String(target.getMonth() + 1).padStart(2, '0');
    const dd = String(target.getDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`;
  }

  const waitForElement = (selector, timeout = 2000) => {
    return new Promise((resolve, reject) => {
      const found = document.querySelector(selector);
      if (found) return resolve(found);

      const obs = new MutationObserver(() => {
        const el = document.querySelector(selector);
        if (el) { obs.disconnect(); resolve(el); }
      });

      obs.observe(document.body, { childList: true, subtree: true });

      if (timeout) {
        setTimeout(() => {
          obs.disconnect();
          reject(new Error(`waitForElement timeout: ${selector}`));
        }, timeout);
      }
    });
  };

  const goHome = () => window.location.href='index.html';

  renderComments();

</script>
</html>
